# 代码说明：

`step1.v`为**CPU译码模块**代码，内含testbench

`step1dlc.v`为**CPU译码模块上板**代码，个人使用，实验不要求

`step2.v`为**ALU模块**代码，内含testbench

`step2.dlc`为**ALU模块上板**代码，实验要求但不强制

`step3.v`为**逐位进位加法器**代码，内含lab2实验文档testbench

`step4.v`为**选择进位加法器**代码，内含testbench

`step4dlc.v`为**超前进位选择加法器**代码，不含testbench，非实验内容但与实验高度相关



# 实验笔记——仅为实验方便做的记录

#### 接口

```verilog
module ALU(
    input [7:0] src1,
    input [7:0] src2,
    input [11:0] op,
    output [7:0] result
);
```

#### ALU设计模块
输入的八位二进制默认是**有符号数**
（补码：最高位表示符号位，0表示正数，1表示负数）

#### 操作码对应的运算
- 12'h001: 加 `+`
- 12'h002: 减 `-`
- 12'h004: 按位与 `&`
- 12'h008: 逻辑或 `||`
- 12'h010: 逻辑左移 `a << b[1:0]`
- 12’h020: 算术右移 `a >>> b[1:0]`
- 12'h040: 循环右移 `a >>>> b[1:0]`


- 12'h080: 有符号小于比较 `<s`
- 12'h100: 无符号小于比较 `<u`
- 12'h200: 加法（若有，保留最高位的进位，舍弃最后一位）
- 12'h400: 异或运算 `^`
- 12'h800: 复杂操作`ι`

#### ι 操作的详细解释
1. 考察`src2[7:4]`，拼接操作数
```verilog
4’bxxx1: {src2[3:0],src1[1:0], src1[7:6]} midop = {src1[5:2]}
4’bxx10: {src2[3:0],src1[5:4], src1[3:2]} midop = {src1[7:6], src1[1:0]}
4’bx100: {src2[3:0],src1[7:6], src1[3:2]} midop = {src1[5:4], src1[1:0]}
4’b1000: {src2[3:0],src1[5:4], src1[1:0]} midop = {src1[7:6], src1[3:2]}
```
2. 根据`midop`，决定循环移位的方向和位移量
`midop[0]`为`1`时，循环左移；`midop[0]`为`0`时，循环右移。
`midop[3:1]`决定循环移位的位移量。



#### STEP3: 实现ALU模块

实现的alu_dlc为4位运算的模块，左四位为op1，右四位是op2，右侧小拨码的右四位是OP(erator)

op = 0010:  1 -3=E（E 为-2的补码: 1110）

op = 0101:  1<<3=8

op = 0110:  C>>>1=E

op = 0111:  3>>1 = 9

op = 1010:  F + 1 = 8

